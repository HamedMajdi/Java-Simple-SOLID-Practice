به نام خدا

# آشنایی با اصول شئ‌گرایی (موسوم به اصول SOLID)

## اهداف
در این آزمایش هدف بر آن است که دانشجویان با به کارگیری اصول SOLID در یک پروژه‌ی عملی ساده آشنا شوند.

## نیازمندی‌ها
آشنایی اولیه با مفاهیم برنامه نویسی و طراحی شی‌گرا که دانشجویان قبلاً در درس برنامه‌سازی پیشرفته با آن آشنا شده‌اند.

## ابزارهای مورد استفاده
- یک Java IDE مانند IntelliJ IDEA و یا Eclipse به همراه jdk حداقل نسخه ۸ 

## منابع آموزشی
- [بیان سریع اصول SOLID](https://aparat.com/v/NUPoJ)
  - توصیه می‌کنیم که حتما یادگیری اصول SOLID را با این فیلم شروع کنید و با منابع بعدی به آن عمق دهید.
- [توضیحاتی در مورد Coupling](https://pages.cpsc.ucalgary.ca/~eberly/Courses/CPSC333/Lectures/Design/cohesion.html)
  - یکی از چالش‌هایی که در برنامه نویسی با آن مواجه می‌شوید، آن است که با یک تغییر کوچک در کد مجبور به انجام تغییرات متعدد در جای جای آن هستید. به چنین وابستگی‌ای در بین اجزای برنامه که منجر به بروز تغییرات منتشر شونده می‌شود، Coupling گفته می‌شود. هدف از به کارگیری اصول شئ‌گرایی، کاهش Coupling است.
- [توضیحاتی در مورد Cohesion](https://pages.cpsc.ucalgary.ca/~eberly/Courses/CPSC333/Lectures/Design/cohesion.html)
  - یکی دیگر از ویژگی‌هایی که باید در برنامه شما برقرار باشد، همبند بودن توابع و رفتارهای داخل هر کلاس است. اصول SOLID به برقراری این وِیژگی کمک می‌کنند.
- اصول شئ‌گرایی: [بخش ۱ (بیست دقیقه پایانی)](https://ocw.sharif.edu/course/385/session/id/8776) | [بخش ۲ (کل جلسه به‌غیر از GRASP)](https://ocw.sharif.edu/course/385/session/id/8777) | [بخش ۳ (نیم‌ساعت اول)](https://ocw.sharif.edu/course/385/session/id/8778)
- [توضیح مثال اسب و عنکبوت](https://github.com/ssc-public/Software-Engineering-Lab/blob/main/resources/SOLID/%D8%B9%D9%86%DA%A9%D8%A8%D9%88%D8%AA%20%D9%8A%DA%A9%20%D8%A7%D8%B3%D8%A8%20%D9%86%D9%8A%D8%B3%D8%AA.pdf)

## مقدمه
در این آزمایش شما خواهید آموخت که چگونه می‌توانید با به کارگیری اصول SOLID، نرم‌افزارهایی را بسازید که از نظر قابلیت نگهداری و بهبود، در وضعیت مطلوبی باشند و مدیریت تغییرات در آن‌ها به آسانی میسر باشد (شک نکنید که به کارگیری این اصول اساسی و بسیاری دیگر از اصول مهندسی نرم افزار، باعث تفاوت شما با سایر همکارانتان خواهد شد)

## بخش اول: توضیحاتی پیرامون برنامه‌ی داده شده
می‌توانید برنامه را از [اینجا](https://github.com/ssc-public/Software-Engineering-Lab/tree/main/resources/SOLID/SOLID-Principles) بارگیری کنید.

### مفروضات مسئله
سناریوی یک سفارش خیلی ساده به شرح زیر است:
1. نام مشتری به سیستم داده می‌شود.
2. سفارش مشتری ثبت می‌شود (که ثبت چندین باره‌ی هرکدام از دو غذا بلامانع است).
3. پس از پایان دریافت سفارش (با فشردن کلید 3) عملیات دریافت سفارش پایان می‌یابد و در مرحله‌ی بعدی، روش ثبت سفارش و روش پرداخت (حضوری و یا آنلاین) تعیین می‌شود.
4. در نهایت فاکتور مشتری در صفحه چاپ شده و اجرای برنامه پایان می‌یابد.

### توضیحاتی اجمالی پیرامون ساختار برنامه

این برنامه، حاوی کلاس‌های زیر است:

![image](https://github.com/ssc-public/Software-Engineering-Lab/assets/45389673/731a2e8a-5554-4897-b951-ee0e901fd24f)

1.	کلاس Main حاوی تابع main بوده و بخش عملیاتی آن را پوشش می‌دهد.
2.	کلاس Order حاوی اطلاعاتی در خصوص سفارش مشتری است و حاوی هیچ و یا تعدادی شی از نوع Food است.
3.	کلاس Food حاوی اطلاعات یک قلم غذا است.
4.	واسط Order Service حاوی توابعی برای ثبت سفارش (آنلاین و حضوری) و نیز توابعی برای پرداخت سفارش (آنلاین و حضوری) است (در مجموع 4 تابع دارد).
5.	برای هرکدام از روش‌های ثبت و پرداخت سفارش یک کلاس در نظر گرفته شده‌است که واسط Order Service را پیاده‌سازی می‌کند. همه‌ی این کلاس‌ها همراه با واسط Order Service در بسته‌ی Payment Service قرار دارد.

## بخش دوم: دستور آزمایش

### گام ۱: افزودن یک روش پرداخت دیگر

1.	بدون آن‌که تابعی را از واسط Payment Service حذف کنید، یک کلاس دیگر تحت نام Phone Order Service ایجاد کنید و در آن، واسط Order Service را پیاده‌سازی کنید. 
2.	سپس یک تابع برای ثبت سفارش تلفنی (ورودی آن نام مشتری است) و یک تابع برای پرداخت سفارش تلفنی (ورودی آن مقدار کل مبلغ پرداختی سفارش است) به واسط Order Service اضافه کنید و آن را در کلاس Phone Order Service پیاده‌سازی کنید.
3.	در بدنه‌ی هر تابع، از یک دستور چاپ ساده بر روی صفحه نمایش استفاده کنید.
4.	در ادامه، سعی کنید که قابلیت سفارش تلفنی را نیز به برنامه اضافه کنید؛ یعنی کاری کنید که کاربر بتواند در قالب روش سوم سفارش خود را ثبت کرده و پرداخت را انجام دهد.
5.	تغییراتی را که در کد فعلی برنامه می‌دهید، در جدول زیر ثبت کنید و در نهایت تعداد کل تغییرات را اعلان کنید.
    - توجه: مواردی که به عنوان تغییرات باید اعلان شود شامل این موارد هستند:
      1. ساخت کلاس جدید
      2. افزودن تابع جدید به کلاس و یا واسط (برای توابع جدید صرفا اعلام تغییر کنید)
      3. هر خطوط پیاپی‌ای که در تابع main و برای افزودن یک قابلیت جدید اضافه می‌کنید. به عنوان مثال اگر سه خط را به منظور تشخیص نوع سفارش جدید اضافه می‌کنید، آن سه خط را در قالب یک تغییر اعلام کنید (البته جزییات آن را در ستون «شرحی کوتاه از تغییر» توضیح دهید).

<table dir='rtl'>
<tbody>
<tr>
<td width="64">
<p><strong>ردیف</strong></p>
</td>
<td width="198">
<p><strong>محل اعمال تغییرات (کلاس/واسط)</strong></p>
</td>
<td width="141">
<p><strong>عنوان تغییر</strong></p>
</td>
<td width="292">
<p><strong>شرحی کوتاه از تغییر</strong></p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۱</strong></p>
</td>
<td width="198">
<p>Order Service</p>
</td>
<td width="141">
<p>افزودن تابع پرداخت تلفنی</p>
</td>
<td width="292">
<p>افزودن یک تابع void با عنوان phone Order Payment</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۲</strong></p>
</td>
<td width="198">
<p>Order Service</p>
</td>
<td width="141">
<p>افزودن تابع ثبت سفارش تلفتی</p>
</td>
<td width="292">
<p>افزودن یک تابع void با عنوان phone Order Payment</p>
</td>
</tr>


<td width="64">
<p><strong>3</strong></p>
</td>
<td width="198">
<p>Online Order Service</p>
</td>
<td width="141">
<p>افزودن تابع های پرداخت تلفنی و سفارش تلفنی</p>
</td>
<td width="292">
<p>با توجه به اینکه اینترفیس تغییر می یابد و متد های جدید اضافه میشود، این متد ها باید توسط کلاسهایی که اینترفیس راimplement میکنند نیز پیاده سازی شوند</p>
</td>
</tr>

<td width="64">
<p><strong>4</strong></p>
</td>
<td width="198">
<p>Onsite Order Service</p>
</td>
<td width="141">
<p>افزودن تابع های پرداخت تلفنی و سفارش تلفنی</p>
</td>
<td width="292">
<p>با توجه به اینکه اینترفیس تغییر می یابد و متد های جدید اضافه میشود، این متد ها باید توسط کلاسهایی که اینترفیس راimplement میکنند نیز پیاده سازی شوند</p>
</td>
</tr>



<td width="64">
<p><strong>5</strong></p>
</td>
<td width="198">
<p>Phone Order Service</p>
</td>
<td width="141">
<p>افزودن تابع های موجود در اینترفیس orderservice</p>
</td>
<td width="292">
<p>در درون کلاس جدید، متد ها اضافه شده و دستور پرینت در متد مربوطه هرکدام گنجانده میشود</p>
</td>
</tr>





<td width="64">
<p><strong>6</strong></p>
</td>
<td width="198">
<p>Main</p>
</td>
<td width="141">
<p>افزودن امکان انتخاب سفارش تلفنی</p>
</td>
<td width="292">
<p>در متد اصلی برنامه، قابلیت انتخاب کلید 3 برای ثبت سفارش تلفنی، و همچنین اضافه کردن منطق مربوط به آن گنجانده شد</p>
</td>
</tr>

</table>

مجموع تعداد تغییرات: 6

### گام ۲: تحلیل و وارسی برنامه از منظر تحقق و یا عدم تحقق اصول SOLID
در خصوص این برنامه‌ای که نوشته شده بود و شما یک قابلیت به آن اضافه کردید، بر اساس اصول SOLID موارد نقض و یا محقق شدن هر کدام از آن اصول را بیان کنید. در بیان موارد تحقق و نقض، علت تحقق و یا نقض را نیز به صورت کامل توضیح دهید:

<table dir='rtl'>
<tbody>
<tr>
<td rowspan="2" width="240">
<p>اصل 1</p>
<p>Single Responsibility</p>
</td>
<td width="95">
<p><strong>موارد تحقق</strong></p>
</td>
<td width="454">
<p>کلاس های food و order به دلیل اینکه هر کدام مسئولیت های یگانه و جدا از هم دارند</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>اینترفیس OrderService  مسئول هم ثبت سفارش و هم پردازش پرداخت هستند، که دو مسئولیت متمایز هستند.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 2</p>
<p>Open-Close Principle (OCP)</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>کد کاملا به اصل پایبند است. زیرا می‌توان انواع جدید سفارش‌ها یا روش‌های پرداخت با ایجاد کلاس‌های جدیدی که واسط OrderService را پیاده‌سازی می‌کنند، اضافه کرد، بدون نیاز به اصلاح کد موجود.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 3</p>
<p>Liskov Substitution Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>کد موجود این اصل را نقض می‌کند زیرا واسطه OrderService دارای متدهایی است که به همه زیرکلاس‌ها قابل اعمال نیستند (برای مثال، متد onlineOrderRegister برای OnSiteOrderService قابل اعمال نیست).</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 4</p>
<p>Interface Segregation Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>این اصل بیان می‌کند که کلاس‌های اعمال کننده نباید مجبور شوند به واسطه‌هایی وابسته شوند که از آن‌ها استفاده نمی‌کنند. کد موجود این اصل را نقض می‌کند زیرا واسطه OrderService شامل متدهایی است که همیشه توسط کلاس‌های پیاده‌سازی‌کننده آن مورد استفاده قرار نمی‌گیرد.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 5</p>
<p>Dependency Inversion Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>کلاس اصلی (Main) به طور مستقیم به کلاس‌های OnlineOrderService، OnSiteOrderService و PhoneOrderService وابسته است که این اصل را نقض می‌کند.</p>
</td>
</tr>
</tbody>
</table>

در خصوص هرکدام از موارد نقض هرکدام از اصول، یک راهکار را به منظور رفع آن مشکل ارایه داده و در جدول زیر ثبت نمایید:

<table dir='rtl'>
<tbody>
<tr>
<td width="168">
<p><strong>اصل مربوطه (از اصول </strong><strong>SOLID</strong><strong>)</strong></p>
</td>
<td width="246">
<p><strong>علت نقض</strong></p>
</td>
<td width="284">
<p><strong>راه حل پیشنهادی</strong></p>
</td>
</tr>
<tr>
<td width="168">
<p>&nbsp;</p>
</td>
<td width="246">
<p>&nbsp;</p>
</td>
<td width="284">
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td width="168">
<p>&nbsp;</p>
</td>
<td width="246">
<p>&nbsp;</p>
</td>
<td width="284">
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td width="168">
<p>&nbsp;</p>
</td>
<td width="246">
<p>&nbsp;</p>
</td>
<td width="284">
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td width="168">
<p>&nbsp;</p>
</td>
<td width="246">
<p>&nbsp;</p>
</td>
<td width="284">
<p>&nbsp;</p>
</td>
</tr>
</tbody>
</table>

### گام ۳: اصلاح موارد نقض
در نهایت، بر اساس تحلیلی که انجام داده‌اید و راه حل‌هایی که در بخش قبل ارایه کردید، کد را اصلاح کرده و بر روی مخزن گیت‌هاب و در پوشه‌ای مجزا از گام قبل commit و push کنید. انتظار می‌رود که تمامی راه حل‌های پیشنهادی خود را بر روی این نسخه اعمال کنید و تمامی بهبودهایی که انجام می‌دهید، در جداول بخش قبل موجود باشد.

### گام ۴: بررسی مجدد تغییرات مورد نیاز
فرض کنید که گام 1 را برای کد اصلاح شده (پس از انجام گام‌های ۲ و ۳) اجرا کرده‌اید.
1. در این صورت از انجام کدام یک از تغییرات ثبت شده در جدول گام ۱ معاف خواهید شد؟
2. تعداد تغییرات مورد نیاز، چند تغییر خواهد شد؟

### گام ۵: جمع بندی
در این بخش، بیان کنید که از این گام چه نتیجه‌ای گرفته‌اید؟ و به نظر شما به کارگیری صحیح اصول SOLID در گام‌های ۳ و ۴ چه مزایایی را نسبت به حالتی دارد که این اصول رعایت نشده‌بود؟

## نحوه ارسال پروژه:
1.	گام ۱ را انجام داده و سپس کد نوشته شده‌ی خود را (با رعایت محدودیت‌های گفته شده در گام) در یک پوشه به نام Step_1_Non_SOLID ذخیره کنید و در مخزن گام ۲ قرار دهید. موارد توضیحی بایستی در بخش README مخزن قرار گیرد.
2.	گام ۲ (که بخش تحلیلی است) در فایل README مربوط به مخزن گام ۲ آورده شود (تمام جداول با فرمت داده شده و عناوین هرکدام از سوالات پرسیده شده بایستی در README آورده شود).
3.	گام ۳ که شامل بهبود است، بایستی به صورت جداگانه در پوشه دیگری به نام Step_3_With_SOLID قرار داده شود و در مخزن موجود باشد.
4.	گام ۴ نیز در قالب توضیحات در README مخزن آورده شود.
5.	گام ۵ (که نتیجه گیری است) در README مخزن آورده شود.
